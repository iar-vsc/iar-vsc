/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

'use strict';

import { spawn } from "child_process";
import { PathLike } from "fs";
import * as path from "path";
import * as Fs from "fs";
import * as sqlite3 from 'sqlite3-offline';
import * as sqlite from 'sqlite';

/**
 * Functions for interacting with C-STAT
 */
export namespace CStat {

    export enum CStatWarningSeverity {
        LOW = 0,
        MEDIUM = 1,
        HIGH = 2,
    }
    export interface CStatWarning {
        file: string;
        line: number;
        col: number;
        message: string;
        severity: CStatWarningSeverity;
        checkId: string;
    }

    type propertyName = "property_alias" | "property_id";

    /** Definition of subset of fields expected in a data row from the CSTAT warnings table */
    interface WarningBase {
        file_name: string;
        iar_seq: number;
        line_num: number;
        column_num: number;
        msg: string;
        severity: string;
    }

    interface WarningWithAlias extends WarningBase {
        property_alias: string;
    }

    interface WarningWithId extends WarningBase {
        property_id: string;
    }

    type Warning = WarningWithAlias | WarningWithId;

    /** Definition of subset of fields expected in a data row from the CSTAT warnings table */
    interface Suppression {
        property_id: string;
        iar_seq_start: number;
        col_start: number;
        iar_seq_end: number;
        col_end: number;
        file: string;
    }

    /**
     * Returns all warnings from the last C-STAT analysis.
     * Queries the sqlite db generated by CSTAT for warnings and suppressions (that is, warnings that have been
     * disabled by the user). If `filter` is set to true, filters the warnings based on said suppressions.
     * 
     * @param projectPath File-system path to the project root.
     * @param configurationName Which IAR configuration is used. Necessary to select the correct CSTAT DB to read from.
     * @param filter Whether to filter the CSTAT warnings based on suppressions.
     * 
     * @returns Parsed and optionally filtered CSTAT warnings.
     */
    export async function getAllWarnings(projectPath: PathLike, configurationName: string, filter: boolean): Promise<CStatWarning[]> {
        const database = getCStatDBPath(projectPath, configurationName);
        const databaseDir = path.resolve(path.dirname(database), "..", "..");
        /** We can't rely on the filename in the database. Some are absolute, some relative. Let's normalize them. */
        const absolutePath = (file: string): string => {
            return path.resolve(databaseDir, file);
        };

        const fields: string[] = ["file_name", "line_num", "column_num", "msg", "severity"];

        let db = await sqlite.open({ filename: database, driver: sqlite3.Database });

        const idColumnQueryResult = await db.run("SELECT sql FROM sqlite_master WHERE type IS 'table' AND name IS 'warnings';");
        const checkIdColumn: propertyName = idColumnQueryResult.toString().includes("property_alias") ? "property_alias" : "property_id";

        const propertyAlias = (warning: Warning): string => {
            return "property_alias" in warning ? (warning as WarningWithAlias).property_alias : (warning as WarningWithId).property_id;
        };

        let warnings: Warning[] = await db.all(`SELECT ${fields.join(", ")}, ${checkIdColumn} from warnings;`);


        warnings.map(warning => {
            warning.file_name = absolutePath(warning.file_name);
            warning.iar_seq = Number(warning.iar_seq);
            warning.line_num = Number(warning.line_num);
            warning.column_num = Number(warning.column_num);

            return warning;
        });

        if (filter) {
            let suppressions: Suppression[] = await db.all(`SELECT * FROM suppression_directives;`);

            suppressions.map(suppression => {
                suppression.file = absolutePath(suppression.file);
                suppression.iar_seq_start = Number(suppression.iar_seq_start);
                suppression.iar_seq_end = Number(suppression.iar_seq_end);

                return suppression;
            });

            // Left-join warnings with suppressions, filtering out all suppressed warnings.
            warnings.filter((warning) => {
                return !suppressions.some((suppression) => {
                    return (propertyAlias(warning) === suppression.property_id) &&
                        (warning.file_name === suppression.file) &&
                        (suppression.iar_seq_start <= warning.iar_seq) &&
                        ((warning.iar_seq <= suppression.iar_seq_end) ||
                            (suppression.iar_seq_end < suppression.iar_seq_start));
                });
            });
        }

        // Final conversion to the format defined by the API...
        return Promise.resolve(warnings.map((warning: Warning) => {
            return {
                file: warning.file_name,
                line: warning.line_num,
                col: warning.column_num,
                message: warning.msg,
                severity: SeverityStringToSeverityEnum(warning.severity),
                checkId: propertyAlias(warning),
            };
        }));
    };

    /**
     * Runs a C-STAT analysis on a given project and configuration
     * (calls IarBuild with the -cstat_analyze parameter)
     */
    export function runAnalysis(builderPath: PathLike, projectPath: PathLike, configurationName: string, onWrite?: (msg: string) => void): Thenable<void> {
        if (!Fs.existsSync(builderPath)) {
            return Promise.reject(`The builder ${builderPath} does not exists.`);
        }

        // It seems we need to delete the db and regenerate it every time to get around
        // some weird behaviour where the db keeps references to files outside the project
        // (specifically when the project is moved or the db is accidentally put under VCS).
        // It seems EW solves this by checking if each file in the db is in the project,
        // but i'm not sure how I would do that in VS Code
        const dbPath = getCStatDBPath(projectPath, configurationName);
        if (Fs.existsSync(dbPath)) { Fs.unlinkSync(dbPath); }

        const iarbuild = spawn(builderPath.toString(), [projectPath.toString(), "-cstat_analyze", configurationName.toString(), "-log", "info"]);
        iarbuild.stdout.on("data", data => {
            if (onWrite) {
                onWrite(data.toString());
            }
        });

        return new Promise<void>((resolve, reject) => {
            iarbuild.on("close", (code) => {
                if (code !== 0) {
                    reject("C-STAT exited with code: " + code);
                } else {
                    resolve(); // C-STAT is done!
                }
            });
        });
    }

    export function SeverityStringToSeverityEnum(severity: string): CStatWarningSeverity {
        switch (severity) {
            case "Low": return CStatWarningSeverity.LOW;
            case "Medium": return CStatWarningSeverity.MEDIUM;
            case "High": return CStatWarningSeverity.HIGH;
            default:
                console.log("Unrecognized C-STAT severity: " + severity);
                return CStatWarningSeverity.HIGH;
        }
    }

    function getCStatDBPath(projectPath: PathLike, configurationName: string) {
        return path.join(path.dirname(projectPath.toString()), configurationName, "Obj", "cstat.db");
    }
}